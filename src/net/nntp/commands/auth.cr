require "../errors"
require "base64"

module Net::NNTP::Commands::Auth
  abstract def socket : Net::NNTP::Socket
  abstract def critical(&block)

  {% begin %}
    {% auth_methods = %w(original simple generic plain starttls external cram_md5 digest_md5 gassapi) %}

    AUTH_METHODS = [
      {% for m in auth_methods %}
      :{{m.id}},
      {% end %}
    ]

    def authenticate(user, secret, method = :original)
        Log.info { "auth.start: [user: #{user}, method: #{method}]" }
        case method
        {% for m in auth_methods %}
        when :{{m.id}}
          auth_{{m.id}}(user, secret)
        {% end %}
        else
          Log.error { "Unsupported auth method: #{method}" }
          raise NNTP::Error::AuthenticationError.new "Unsupported auth method: #{method}"
        end
    end

    {% for m in auth_methods %}
      private def auth_{{m.id}}(user, secret)
        raise NotImplementedError.new(%<Auth for method "{{m.id}}" has not been implimented>)
      end
    {% end %}
  {% end %}

  # [RFC2980]
  # 3.1.1 Original AUTHINFO
  #
  #    AUTHINFO USER username
  #    AUTHINFO PASS password
  #
  #    The original AUTHINFO is used to identify a specific entity to the
  #    server using a simple username/password combination.  It first
  #    appeared in the UNIX reference implementation.
  #
  #    When authorization is required, the server will send a 480 response
  #    requesting authorization from the client.  The client must enter
  #    AUTHINFO USER followed by the username.  Once sent, the server will
  #    cache the username and may send a 381 response requesting the
  #    password associated with that username.  Should the server request a
  #    password using the 381 response, the client must enter AUTHINFO PASS
  #    followed by a password and the server will then check the
  #    authentication database to see if the username/password combination
  #    is valid.  If the combination is valid or if no password is required,
  #    the server will return a 281 response.  The client should then retry
  #    the original command to which the server responded with the 480
  #    response.  The command should then be processed by the server
  #    normally.  If the combination is not valid, the server will return a
  #    502 response.
  #
  #    Clients must provide authentication when requested by the server.  It
  #    is possible that some implementations will accept authentication
  #    information at the beginning of a session, but this was not the
  #    original intent of the specification.  If a client attempts to
  #    reauthenticate, the server may return 482 response indicating that
  #    the new authentication data is rejected by the server.  The 482 code
  #    will also be returned when the AUTHINFO commands are not entered in
  #    the correct sequence (like two AUTHINFO USERs in a row, or AUTHINFO
  #    PASS preceding AUTHINFO USER).

  #    All information is passed in cleartext.
  #
  #    When authentication succeeds, the server will create an email address
  #    for the client from the user name supplied in the AUTHINFO USER
  #    command and the hostname generated by a reverse lookup on the IP
  #    address of the client.  If the reverse lookup fails, the IP address,
  #    represented in dotted-quad format, will be used.  Once authenticated,
  #    the server shall generate a Sender:  line using the email address
  #    provided by authentication if it does not match the client-supplied
  #    From: line.  Additionally, the server should log the event, including
  #    the email address.  This will provide a means by which subsequent
  #    statistics generation can associate newsgroup references with unique
  #    entities - not necessarily by name.
  #
  # 3.1.1.1 Responses
  #
  #       281 Authentication accepted
  #       381 More authentication information required
  #       480 Authentication required
  #       482 Authentication rejected
  #       502 No permission
  private def auth_original(user, secret)
    resp = critical {
      socket.send("AUTHINFO USER %s", user).check!(true)
      socket.send("AUTHINFO PASS %s", secret, quiet: true).check!(true)
    }
    raise NNTP::Error::AuthenticationError.new(resp.to_s) unless /\A2../ === resp.status
  end

  # [RFC2980]
  # 3.1.2 AUTHINFO SIMPLE
  #
  #    AUTHINFO SIMPLE
  #    user password
  #
  #    This version of AUTHINFO was part of a proposed NNTP V2
  #    specification, which was started in 1991 but never completed, and is
  #    implemented in some servers and clients.  It is a refinement of the
  #    original AUTHINFO and provides the same basic functionality, but the
  #    sequence of commands is much simpler.
  #
  #    When authorization is required, the server sends a 450 response
  #    requesting authorization from the client.  The client must enter
  #    AUTHINFO SIMPLE.  If the server will accept this form of
  #    authentication, the server responds with a 350 response.  The client
  #    must then send the username followed by one or more space characters
  #    followed by the password.  If accepted, the server returns a 250
  #    response and the client should then retry the original command to
  #    which the server responded with the 450 response.  The command should
  #    then be processed by the server normally.  If the combination is not
  #    valid, the server will return a 452 response.
  #
  #    Note that the response codes used here were part of the proposed NNTP
  #    V2 specification and are violations of RFC 977.  It is recommended
  #    that this command not be implemented, but use either or both of the
  #    other forms of AUTHINFO if such functionality if required.
  # 3.1.2.1 Responses
  #
  #       250 Authorization accepted
  #       350 Continue with authorization sequence
  #       450 Authorization required for this command
  #       452 Authorization rejected
  private def auth_simple(user, secret)
    resp = critical {
      socket.send("AUTHINFO SIMPLE").check!(true)
      socket.send("%s %s", user, secret, quiet: true).check!(true)
    }
    raise NNTP::Error::AuthenticationError.new(resp.to_s) unless /\A2../ === resp.status
  end

  # [RFC2980]
  # 3.1.3 AUTHINFO GENERIC
  #
  #    AUTHINFO GENERIC authenticator arguments...
  #
  #    AUTHINFO GENERIC is used to identify a specific entity to the server
  #    using arbitrary authentication  or identification protocols.  The
  #    desired protocol is indicated by the authenticator parameter, and any
  #    number of parameters can be passed to the authenticator.
  #
  #    When authorization is required, the server will send a 480 response
  #    requesting authorization from the client.  The client should enter
  #    AUTHINFO GENERIC followed by the authenticator name, and the
  #    arguments if any.  The authenticator and arguments must not contain
  #    the sequence "..".
  #
  #    The server will attempt to engage the server end authenticator,
  #    similarly, the client should engage the client end authenticator.
  #    The server end authenticator will then initiate authentication using
  #    the NNTP sockets (if appropriate for that authentication protocol),
  #    using the protocol specified by the authenticator name.  These
  #    authentication protocols are not included in this document, but are
  #    similar in structure to those referenced in RFC 1731 [8] for the
  #    IMAP-4 protocol.
  #
  #    If the server returns 501, this means that the authenticator
  #    invocation was syntactically incorrect, or that AUTHINFO GENERIC is
  #    not supported.  The client should retry using the AUTHINFO USER
  #    command.
  #
  #    If the requested authenticator capability is not found, the server
  #    returns the 503 response code.
  #
  #    If there is some other unspecified server program error, the server
  #    returns the 500 response code.
  #
  #    The authenticators converse using their protocol until complete.  If
  #    the authentication succeeds, the server authenticator will terminate
  #    with a 281, and the client can continue by reissuing the command that
  #    prompted the 380.  If the authentication fails, the server will
  #    respond with a 502.
  #
  #    The client must provide authentication when requested by the server.
  #    The server may request authentication at any time.  Servers may
  #    request authentication more than once during a single session.
  #
  #    When the server authenticator completes, it provides to the server
  #    (by a mechanism herein undefined) the email address of the user, and
  #    potentially what the user is allowed to access.  Once authenticated,
  #    the server shall generate a Sender:  line using the email address
  #    provided by the authenticator if it does not match the user-supplied
  #    From: line.  Additionally, the server should log the event, including
  #    the user's authenticated email address (if available).  This will
  #    provide a means by which subsequent statistics generation can
  #    associate newsgroup references with unique entities - not necessarily
  #    by name.
  #
  #    Some implementations make it possible to obtain a list of
  #    authentication procedures available by sending the server AUTHINFO
  #    GENERIC with no arguments.  The server then returns a list of
  #    supported mechanisms followed by a period on a line by itself.
  #
  # 3.1.3.1 Responses
  #
  #       281 Authentication succeeded
  #       480 Authentication required
  #       500 Command not understood
  #       501 Command not supported
  #       502 No permission
  #       503 Program error, function not performed
  #       nnn  authenticator-specific protocol.
  #
  # The authentication protocols are not inculeded in RFC2980,
  # see [RFC1731] (http://www.ietf.org/rfc/rfc1731.txt).
  private def auth_generic(fmt, *args)
    resp = critical {
      cmd = "AUTHINFO GENERIC " + sprintf(fmt, *args)
      socket.send(cmd, quiet: true).check!(true)
    }
    raise NNTP::Error::AuthenticationError.new(resp.to_s) unless /\A2../ === resp.status
  end

  # [RFC2980]
  # AUTHINFO SASL PLAIN
  private def auth_plain(user, secret)
    resp = critical {
      socket.send("AUTHINFO SASL PLAIN %s",
        Base64.encode("\0#{user}\0#{secret}"), quiet: true).check!(true)
    }
    raise NNTP::Error::AuthenticationError.new(resp.to_s) unless /\A2../ === resp.status
  end
end
